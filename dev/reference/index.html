<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Newtman.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Newtman.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../guide/">Guide</a></li><li><a class="toctext" href="../algorithms/">Implementations</a></li><li><a class="toctext" href="../benchmarks/">Benchmark functions</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Benchmarks-1">Benchmarks</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li><li><a class="toctext" href="#Population-1">Population</a></li></ul></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/edwinb-ai/Newtman.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Benchmarks-1" href="#Benchmarks-1">Benchmarks</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Ackley" href="#Newtman.Ackley"><code>Newtman.Ackley</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Ackley</code></pre><p>An unconstrained implementation of the d-dimensional Ackley function defined as:</p><div>\[f(\mathbf{x}) = -20 e^{ -0.02 \sqrt{\frac{1}{d}\sum_{i=1}^{d}{x_i^2}}} - e^{\frac{1}{d}\sum_{i=1}^{d}{\cos{(2 \pi x_i)}}} + 20 + e\]</div><p>where <span>$d$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/test-functions/implementations.jl#L44-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Easom" href="#Newtman.Easom"><code>Newtman.Easom</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Easom</code></pre><p>An unconstrained implementation of the 2-dimensional Easom function defined as:</p><div>\[f(\mathbf{x}) = -\cos{(x_1)} \cos{(x_2)} \exp{[-(x_1 - \pi)^2 - (x_2 - \pi)^2]}\]</div><p>where <span>$x_1$</span> and <span>$x_2$</span> refer to the first and second element of the input vector <span>$\mathbf{x}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/test-functions/implementations.jl#L20-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Rosenbrock" href="#Newtman.Rosenbrock"><code>Newtman.Rosenbrock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Rosenbrock</code></pre><p>An unconstrained implementation of the d-dimensional Rosenbrock function defined as:</p><div>\[f(\mathbf{x}) = \sum_{i=1}^{N-1} \left[100(x_{i-1}-x_i^2)^2 +(1-x_i)^2 \right]\]</div><p>where <span>$N$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/test-functions/implementations.jl#L68-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Sphere" href="#Newtman.Sphere"><code>Newtman.Sphere</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Sphere</code></pre><p>An unconstrained implementation of the Sphere function defined as:</p><div>\[f(\mathbf{x}) = \sum_{i=1}^{d} x_i^2\]</div><p>where <span>$d$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/test-functions/implementations.jl#L3-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.TestFunctions" href="#Newtman.TestFunctions"><code>Newtman.TestFunctions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TestFunctions</code></pre><p>Abstract supertype for all benchmark functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/test-functions/functions.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Unconstrained" href="#Newtman.Unconstrained"><code>Newtman.Unconstrained</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Unconstrained</code></pre><p>Abstract supertype for all unconstrained benchmark functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/test-functions/functions.jl#L8-L12">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Metaheuristic" href="#Newtman.Metaheuristic"><code>Newtman.Metaheuristic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Metaheuristic</code></pre><p>Abstract type for metaheuristic algorithms, this makes a clear distinction between different classifications of metaheuristic algorithms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/solvers.jl#L8-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.OptimizationResults" href="#Newtman.OptimizationResults"><code>Newtman.OptimizationResults</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OptimizationResults{T, U, V, W}</code></pre><p>Type that formats the output of <a href="#Newtman.Solver"><code>Solver</code></a> to get better information from it.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: Stores the <em>solution</em> array from the solver, i.e. the solution that minimizes   the cost function.</li><li><code>min::U</code>: Stores the value obtained from evaluating the cost function with   <code>x</code>, i.e. the minima found.</li><li><code>impl::AbstractString</code>: Stores the name of the <code>Solver</code> used, i.e. the name or identifier of the   optimization algorithm.</li><li><code>iterations::Integer</code>: Stores the number of maximum iterations that the solver was run.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/solvers.jl#L35-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.PopulationBase" href="#Newtman.PopulationBase"><code>Newtman.PopulationBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PopulationBase</code></pre><p>Type for population-based algorithms that employ <a href="#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}"><code>Population</code></a>, i.e. subroutines that <em>mutate</em> an array of possible candidates in-place. An example of this type is <a href="#Newtman.PSO"><code>PSO</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/solvers.jl#L16-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.PSO" href="#Newtman.PSO"><code>Newtman.PSO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PSO</code></pre><p><code>PSO</code> is the type associated with the implementation for the Particle Swarm Optimization with momentum. See <a href="../algorithms/#implementations-docs-1"><code>Algorithms</code></a> for more information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/pso.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.PSO-Tuple{Function,AbstractArray,Int64}" href="#Newtman.PSO-Tuple{Function,AbstractArray,Int64}"><code>Newtman.PSO</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PSO(f::Function, population::AbstractArray, k_max::Int;
    w=0.9, c1=2.0, c2=2.0) -&gt; OptimizationResults</code></pre><p>Method that implements <code>PSO</code> for a function <code>f</code> of type <code>Function</code>, or of type <code>TestFunctions</code>. Returns an <code>OptimizationResults</code> type with information relevant to the run executed, see <a href="#Newtman.OptimizationResults"><code>OptimizationResults</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>population</code>: can be any <code>AbstractArray</code> that contains <a href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray"><code>Particle</code></a></li></ul><p>instances, but it is expected to be generated by <a href="#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}"><code>Population</code></a>.</p><ul><li><code>k_max</code>: number of maximum iterations until &quot;convergence&quot; of the algorithm.</li></ul><p><strong>Keyword arguments</strong></p><p><em>It is recommended to use the default values provided.</em></p><ul><li><code>w</code>: value that controls how much of the initial velocity is retained, i.e.</li></ul><p>an inertia term. This values decays linearly over each iteration until it reaches the default miminum value of 0.4.</p><ul><li><code>c1</code>: balance between the influence of the individual&#39;s knowledge, i.e. the</li></ul><p>best inidividual solution so far.</p><ul><li><code>c2</code>: balance between the influence of the population&#39;s knowledge, i.e. the</li></ul><p>best global solution so far.</p><p><strong>Examples</strong></p><ul><li>For <code>Function</code>s</li></ul><pre><code class="language-julia">using Newtman

# Define the Sphere function
f_sphere(x) = sum(x .^ 2)

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 30 particles in the population.
val = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000)</code></pre><ul><li>For <code>TestFunctions</code></li></ul><pre><code class="language-julia">using Newtman

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 25 particles in the population.
val = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/pso.jl#L10-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat" href="#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat"><code>Newtman.SimulatedAnnealing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SimulatedAnnealing(f::Function, a::T, b::T, dim::Integer;
    t0 = 500.0, low_temp = 5000) where {T &lt;: AbstractFloat} -&gt; OptimizationResults</code></pre><p>Implementation of the <em>classical</em> version of simulated annealing. This implementation uses a logarithmic cooling schedule and searches possible candidate solutions by sampling from an approximate Boltzmann distribution, drawn as a normal distribution.</p><p>Returns an <code>OptimizationResults</code> type with information relevant to the run executed, see <a href="#Newtman.OptimizationResults"><code>OptimizationResults</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: any user defined <code>Function</code> that can take <code>AbstractArray</code>&#39;s.</li><li><code>a</code>: <strong>lower</strong> bound for the solution search space.</li><li><code>b</code>: <strong>upper</strong> bound for the solution search space.</li><li><code>dim</code>: dimension of the optimization problem.</li></ul><p><strong>Keyword arguments</strong></p><p><em>It is recommended to use the default values provided.</em></p><ul><li><code>t0</code>: initial value for the <em>temperature</em> that is used. The default is an okay</li></ul><p>value, but should be changed depending on the optimization problem.</p><ul><li><code>low_temp</code>: total number of iterations, short for <em>lowering temperature steps</em>.</li></ul><p>This also corresponds to the famous <em>Monte Carlo steps</em>, which are the total number of steps until the algorithm finishes.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Define the 2D Rosenbrock function
rosenbrock2d(x) =  (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2

# Implement Simulated Annealing for a 2-dimensional Rosenbrock function, with
# 5000 iterations.
val = SimulatedAnnealing(rosenbrock2d, -5.0, 5.0, 2; low_temp = 5000)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/simulated_annealing.jl#L28-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Newtman.TestFunctions,T,T,Integer}} where T&lt;:AbstractFloat" href="#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Newtman.TestFunctions,T,T,Integer}} where T&lt;:AbstractFloat"><code>Newtman.SimulatedAnnealing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SimulatedAnnealing(f::TestFunctions, a::T, b::T, dim::Integer;
    t0 = 500.0, low_temp = 5000) where {T &lt;: AbstractFloat} -&gt; OptimizationResults</code></pre><p>Same implementation as the one for <a href="#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat"><code>SimulatedAnnealing</code></a> except that this one can accept <code>TestFunctions</code> functions implemented within <code>Newtman</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Implement Simulated Annealing for a 3-dimensional Rosenbrock function, with
# 10000 iterations.
val = SimulatedAnnealing(Rosenbrock(), -5.0, 5.0, 3; low_temp = 10000)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/simulated_annealing.jl#L5-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Solver" href="#Newtman.Solver"><code>Newtman.Solver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Solver</code></pre><p>Abstract super-type for every algorithm implementation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/solvers.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._clip_positions_velocities!-Tuple{Any}" href="#Newtman._clip_positions_velocities!-Tuple{Any}"><code>Newtman._clip_positions_velocities!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Apply boundary conditions to both position and velocity for every <code>Particle</code> type object <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/pso.jl#L136-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._create_rng-Tuple{}" href="#Newtman._create_rng-Tuple{}"><code>Newtman._create_rng</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns <code>num_rngs</code> number of statistically independent pseudo-random number generators by creating a master RNG and drawing numbers from it, these numbers will serve as seeds for the number of RNG&#39;s returned in the form of an <code>AbstractArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/pso.jl#L153-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._weight_decay-Tuple{Any,Any}" href="#Newtman._weight_decay-Tuple{Any,Any}"><code>Newtman._weight_decay</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute the corresponding weight decay depending the maximum number of iterations and the initial value for it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/pso.jl#L125-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._classical_visit-Tuple{AbstractArray,AbstractArray,AbstractFloat,Any}" href="#Newtman._classical_visit-Tuple{AbstractArray,AbstractArray,AbstractFloat,Any}"><code>Newtman._classical_visit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>This scheme approximates a Boltzmann distribution</p><div>\[p_i = \frac{e^{-\varepsilon_i/kT}}{\sum_j e^{-\varepsilon_j/kT}\]</div><p>where <span>$k$</span> is the Boltzmann constant, <span>$T$</span> is the temperature, and <span>$\varepsilon$</span> is the energy at <em>state</em> <span>$i$</span>.</p><p>The approximation is done by means of a standard normal distribution like so</p><div>\[p_i \sym \mathcal{N}(0, \sqrt{T})\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/solvers/simulated_annealing.jl#L107-L121">source</a></section><h2><a class="nav-anchor" id="Population-1" href="#Population-1">Population</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray" href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray"><code>Newtman.Particle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Particle(x::T, v::T, x_best::T, a::V, b::V)
    where {T&lt;:AbstractArray, V&lt;:AbstractFloat}</code></pre><p>A type that can hold information about current position, current velocity, the <em>best</em> candidate to a solution, as well as defining the bounds. The dimensions of the <code>Particle</code> are inferred from the length of the arrays.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Array that holds the <strong>positions</strong> of possible solutions.</li><li><code>v</code>: Array that holds <strong>velocities</strong> related to <code>x</code>.</li><li><code>x_best</code>: An element of <code>x</code> that determines the best position for the particle.</li><li><code>a</code>: lower bound for <code>x</code></li><li><code>b</code>: upper bound for <code>v</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">p = Particle(zeros(3), rand(3), zeros(3), -1.0, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/population/types.jl#L24-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V&lt;:Int64 where T&lt;:AbstractFloat" href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V&lt;:Int64 where T&lt;:AbstractFloat"><code>Newtman.Particle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Particle(a::T, b::T, n::V)
    where {T&lt;:AbstractFloat, V&lt;:Int}</code></pre><p><code>Particle</code> that can be created randomly using the bounds and the dimension needed.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: lower bound for <code>x</code></li><li><code>b</code>: upper bound for <code>v</code></li><li><code>n</code>: dimension for <code>x</code>, <code>v</code>, and <code>x_best</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">p = Particle(-1.0, 1.0, 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/population/types.jl#L47-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}" href="#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}"><code>Newtman.Population</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Population(num_particles::Integer, dim::Integer, x...)
    -&gt; Vector{Particle}(undef, num_particles)</code></pre><p>An array of <code>Particle</code>&#39;s where each of them are bounded and are given a dimension. <code>x</code> is a tuple of ranges for each <em>dimension</em> for the <code>Particle</code>&#39;s specified.</p><p><strong>Arguments</strong></p><ul><li><code>num_particles</code>: Number of particles in the <code>Population</code>.</li><li><code>dim</code>: Dimension for every <code>Particle</code>.</li><li><code>x</code>: Tuple of ranges for each dimension.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Two ranges, one for each dimension
range_a = SVector(-10.0, 10.0)
range_b = SVector(-2.5, 2.0)
pops = Population(2, 20, ranges_a, range_b)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/population/types.jl#L107-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64" href="#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64"><code>Newtman.Population</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Population(num_particles::T, dim::T, a::V, b::V)
    where {T&lt;:Int, V&lt;:AbstractFloat} -&gt; Vector{Particle}(undef, num_particles)</code></pre><p>An array of <code>Particle</code>s where each of them are bounded and are given a dimension. This is essentially a multi-dimensional array. It makes handling <code>Particle</code>s much easier.</p><p><strong>Arguments</strong></p><ul><li><code>num_particles</code>: Number of particles in the <code>Population</code>.</li><li><code>dim</code>: Dimension for every <code>Particle</code>.</li><li><code>a</code>: Lower bound for every <code>Particle</code>, this is shared across every instance.</li><li><code>b</code>: Upper bound for every <code>Particle</code>, this is shared across every instance.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">pop = Population(35, 4, -1.0, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/population/types.jl#L77-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Individual" href="#Newtman.Individual"><code>Newtman.Individual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Individual</code></pre><p>Abstract super-type for types that contain their own information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/cd5033c29cc62775f846a8ceb185d15028c40f52/src/population/types.jl#L1-L5">source</a></section><footer><hr/><a class="previous" href="../benchmarks/"><span class="direction">Previous</span><span class="title">Benchmark functions</span></a><a class="next" href="../license/"><span class="direction">Next</span><span class="title">License</span></a></footer></article></body></html>
