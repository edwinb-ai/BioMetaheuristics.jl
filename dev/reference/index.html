<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Newtman.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Newtman.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Guide</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../algorithms/">Implementations</a></li><li><a class="tocitem" href="../benchmarks/">Benchmark functions</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Benchmarks"><span>Benchmarks</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Population"><span>Population</span></a></li></ul></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/edwinb-ai/Newtman.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Benchmark" href="#Newtman.TestFunctions.Benchmark"><code>Newtman.TestFunctions.Benchmark</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Benchmark</code></pre><p>Abstract supertype for all benchmark functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/TestFunctions.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Unconstrained" href="#Newtman.TestFunctions.Unconstrained"><code>Newtman.TestFunctions.Unconstrained</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Unconstrained</code></pre><p>Abstract supertype for all unconstrained benchmark functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/TestFunctions.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Ackley" href="#Newtman.TestFunctions.Ackley"><code>Newtman.TestFunctions.Ackley</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ackley</code></pre><p>An unconstrained implementation of the d-dimensional Ackley function defined as:</p><div>\[f(\mathbf{x}) = -20 e^{ -0.02 \sqrt{\frac{1}{d}\sum_{i=1}^{d}{x_i^2}}} - e^{\frac{1}{d}\sum_{i=1}^{d}{\cos{(2 \pi x_i)}}} + 20 + e\]</div><p>where <span>$d$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L40-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Beale" href="#Newtman.TestFunctions.Beale"><code>Newtman.TestFunctions.Beale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Beale</code></pre><p>An unconstrained implementation of the d-dimensional Beale function defined as:</p><div>\[f(x, y) = (1.5-x+xy)^2+(2.25-x+xy^2)^2+(2.625-x+xy^3)^2\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L116-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Easom" href="#Newtman.TestFunctions.Easom"><code>Newtman.TestFunctions.Easom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Easom</code></pre><p>An unconstrained implementation of the 2-dimensional Easom function defined as:</p><div>\[f(\mathbf{x}) = -\cos{(x_1)} \cos{(x_2)} \exp{[-(x_1 - \pi)^2 - (x_2 - \pi)^2]}\]</div><p>where <span>$x_1$</span> and <span>$x_2$</span> refer to the first and second element of the input vector <span>$\mathbf{x}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.GoldsteinPrice" href="#Newtman.TestFunctions.GoldsteinPrice"><code>Newtman.TestFunctions.GoldsteinPrice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Goldstein-Price</code></pre><p>An unconstrained implementation of the d-dimensional Goldstein-Price function defined as:</p><div>\[f(x,y)=[1 + (x + y + 1)^2(19 − 14x+3x^2− 14y + 6xy + 3y^2)] \times \\
[30 + (2x − 3y)^2(18 − 32x + 12x^2 + 4y − 36xy + 27y^2)]\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L90-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Levy" href="#Newtman.TestFunctions.Levy"><code>Newtman.TestFunctions.Levy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lévy</code></pre><p>An unconstrained implementation of the d-dimensional Lévy function defined as:</p><div>\[f(\mathbf{x}) = \sin^{2}{\pi w_1} + \sum_{i=1}^{d-1} (w_i-1)^2 [1+10\sin^{2}{\pi w_1 + 1}]
+ (w_d-1)^2 [1+\sin^{2}{2\pi w_d}]\]</div><p>where</p><p><span>$w_i = 1 + \frac{x_i-1}{4}$</span> and <span>$d$</span> is the dimension of the vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L138-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Rosenbrock" href="#Newtman.TestFunctions.Rosenbrock"><code>Newtman.TestFunctions.Rosenbrock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Rosenbrock</code></pre><p>An unconstrained implementation of the d-dimensional Rosenbrock function defined as:</p><div>\[f(\mathbf{x}) = \sum_{i=1}^{N-1} \left[100(x_{i-1}-x_i^2)^2 +(1-x_i)^2 \right]\]</div><p>where <span>$N$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.TestFunctions.Sphere" href="#Newtman.TestFunctions.Sphere"><code>Newtman.TestFunctions.Sphere</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Sphere</code></pre><p>An unconstrained implementation of the Sphere function defined as:</p><div>\[f(\mathbf{x}) = \sum_{i=1}^{d} x_i^2\]</div><p>where <span>$d$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/TestFunctions/implementations.jl#L1-L11">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Newtman.Metaheuristic" href="#Newtman.Metaheuristic"><code>Newtman.Metaheuristic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Metaheuristic</code></pre><p>Abstract type for metaheuristic algorithms, this makes a clear distinction between different classifications of metaheuristic algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/solvers.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.OptimizationResults" href="#Newtman.OptimizationResults"><code>Newtman.OptimizationResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimizationResults{T, U, V, W}</code></pre><p>Type that formats the output of <a href="#Newtman.Solver"><code>Solver</code></a> to get better information from it.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: Stores the <em>solution</em> array from the solver, i.e. the solution that minimizes   the cost function.</li><li><code>min::U</code>: Stores the value obtained from evaluating the cost function with   <code>x</code>, i.e. the minima found.</li><li><code>impl::AbstractString</code>: Stores the name of the <code>Solver</code> used, i.e. the name or identifier of the   optimization algorithm.</li><li><code>iterations::Integer</code>: Stores the number of maximum iterations that the solver was run.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/solvers.jl#L27-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.PopulationBase" href="#Newtman.PopulationBase"><code>Newtman.PopulationBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PopulationBase</code></pre><p>Type for population-based algorithms that employ <a href="#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}"><code>Population</code></a>, i.e. subroutines that <em>mutate</em> an array of possible candidates in-place. An example of this type is <a href="#Newtman.PSO"><code>PSO</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/solvers.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.Solver" href="#Newtman.Solver"><code>Newtman.Solver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Solver</code></pre><p>Abstract super-type for every algorithm implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/solvers.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.PSO" href="#Newtman.PSO"><code>Newtman.PSO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSO</code></pre><p><code>PSO</code> is the type associated with the implementation for the Particle Swarm Optimization with momentum. See <a href="../algorithms/#implementations-docs"><code>Algorithms</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/pso.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.PSO-Tuple{Benchmark,AbstractArray,Int64}" href="#Newtman.PSO-Tuple{Benchmark,AbstractArray,Int64}"><code>Newtman.PSO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PSO(f::Benchmark, population::AbstractArray, k_max::Int;
    w=0.9, c1=2.0, c2=2.0, seed = nothing
    ) -&gt; OptimizationResults</code></pre><p>Method that implements <code>PSO</code> for a function <code>f</code> of type <code>Benchmark</code>. Same implementation as the one for <code>Function</code>&#39;s.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 25 particles in the population.
val = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/pso.jl#L67-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.PSO-Tuple{Function,AbstractArray,Int64}" href="#Newtman.PSO-Tuple{Function,AbstractArray,Int64}"><code>Newtman.PSO</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PSO(f::Function, population::AbstractArray, k_max::Int;
    w=0.9, c1=2.0, c2=2.0, seed = nothing
    ) -&gt; OptimizationResults</code></pre><p>Method that implements <code>PSO</code> for a function <code>f</code> of type <code>Function</code>, or of type <code>TestFunctions</code>. Returns an <code>OptimizationResults</code> type with information relevant to the run executed, see <a href="#Newtman.OptimizationResults"><code>OptimizationResults</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>population</code>: can be any <code>AbstractArray</code> that contains <a href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray"><code>Particle</code></a></li></ul><p>instances, but it is expected to be generated by <a href="#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}"><code>Population</code></a>.</p><ul><li><code>k_max</code>: number of maximum iterations until &quot;convergence&quot; of the algorithm.</li></ul><p><strong>Keyword arguments</strong></p><p><em>It is recommended to use the default values provided.</em></p><ul><li><code>w</code>: value that controls how much of the initial velocity is retained, i.e.</li></ul><p>an inertia term. This values decays linearly over each iteration until it reaches the default miminum value of 0.4.</p><ul><li><code>c1</code>: balance between the influence of the individual&#39;s knowledge, i.e. the</li></ul><p>best inidividual solution so far.</p><ul><li><code>c2</code>: balance between the influence of the population&#39;s knowledge, i.e. the</li></ul><p>best global solution so far.</p><ul><li><code>seed</code>: an integer to be used as the seed for the pseudo random number generators.</li></ul><p>If <code>nothing</code> is passed (the default), then a random seed will be taken from the system.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Define the Sphere function
f_sphere(x) = sum(x .^ 2)

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 30 particles in the population.
val = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/pso.jl#L12-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman._clip_positions_velocities!-Tuple{Any}" href="#Newtman._clip_positions_velocities!-Tuple{Any}"><code>Newtman._clip_positions_velocities!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Apply boundary conditions to both position and velocity for every <code>Particle</code> type object <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/pso.jl#L174-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman._create_rng-Tuple{}" href="#Newtman._create_rng-Tuple{}"><code>Newtman._create_rng</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns <code>num_rngs</code> number of statistically independent pseudo-random number generators by creating a master RNG and drawing numbers from it, these numbers will serve as seeds for the number of RNG&#39;s returned in the form of an <code>AbstractArray</code>.</p><p>If instead a <code>seed</code> is passed, that will be used as a seed for a single random number generator, which will then be used to create seed for more RNGs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/pso.jl#L191-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman._weight_decay-Tuple{Any,Any}" href="#Newtman._weight_decay-Tuple{Any,Any}"><code>Newtman._weight_decay</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the corresponding weight decay depending the maximum number of iterations and the initial value for it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/pso.jl#L163-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.GeneralSimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat" href="#Newtman.GeneralSimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat"><code>Newtman.GeneralSimulatedAnnealing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeneralSimulatedAnnealing(
    f::Benchmark, a::T, b::T, dim::Integer;
    t0 = 500.0, low_temp = 20000, qv = 2.7, qa = -5.0
    ) where {T &lt;: AbstractFloat} -&gt; OptimizationResults</code></pre><p>Same implementation as the one for <a href="#Newtman.GeneralSimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat"><code>GeneralSimulatedAnnealing</code></a> except that this one can accept <code>Benchmark</code> functions implemented within <code>Newtman.TestFunctions</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Implement General Simulated Annealing for a 3-dimensional Rosenbrock function, with
# 10000 iterations.
val = GeneralSimulatedAnnealing(Rosenbrock(), -5.0, 5.0, 3; low_temp = 10000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L164-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.GeneralSimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat" href="#Newtman.GeneralSimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat"><code>Newtman.GeneralSimulatedAnnealing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GeneralSimulatedAnnealing(
    f::Function, a::T, b::T, dim::Integer;
    t0 = 500.0, low_temp = 5000, qv = 2.7, qa = -5.0,
    seed = nothing
    ) where {T &lt;: AbstractFloat} -&gt; OptimizationResults</code></pre><p>Implementation of the <em>generalized</em> version of simulated annealing. This implementation uses all the theory from Tsallis &amp; Stariolo for the cooling schedule and the neighbor solution search. See <a href="#Newtman.GeneralSimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat"><code>GeneralSimulatedAnnealing</code></a> for the implementation details.</p><p>Returns an <code>OptimizationResults</code> type with information relevant to the run executed, see <a href="#Newtman.OptimizationResults"><code>OptimizationResults</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: any user defined <code>Function</code> that can take <code>AbstractArray</code>&#39;s.</li><li><code>a</code>: <strong>lower</strong> bound for the solution search space.</li><li><code>b</code>: <strong>upper</strong> bound for the solution search space.</li><li><code>dim</code>: dimension of the optimization problem.</li></ul><p><strong>Keyword arguments</strong></p><p><em>It is recommended to use the default values provided.</em></p><ul><li><code>t0</code>: initial value for the <em>temperature</em> that is used. The default is an okay</li></ul><p>value, but should be changed depending on the optimization problem.</p><ul><li><code>low_temp</code>: total number of iterations, short for <em>lowering temperature steps</em>.</li></ul><p>This also corresponds to the famous <em>Monte Carlo steps</em>, which are the total number of steps until the algorithm finishes.</p><ul><li><code>qv</code>: This is known as the <em>Tsallis parameter</em>; particularly this parameter</li></ul><p>controls the cooling schedule convergence and neighbor search. Positive values in the interval <span>$[1,5/3)$</span> are best because for values larger than 5/3 the neighbor search diverges.</p><ul><li><code>qa</code>: Another <em>Tsallis parameter</em>; this particular parameter controls convergence</li></ul><p>for the Metropolis-Hastings algorithm and the acceptance probability involved. The more negative the value is, the better, but Tsallis &amp; Stariolo report that the default value is best.</p><ul><li><code>seed</code>: an integer to be used as the seed for the pseudo random number generators.</li></ul><p>If <code>nothing</code> is passed (the default), then a random seed will be taken from the system.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Define the 2D Rosenbrock function
rosenbrock2d(x) =  (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2

# Implement Simulated Annealing for a 2-dimensional Rosenbrock function, with
# 15000 iterations and default values.
val = GeneralSimulatedAnnealing(rosenbrock2d, -5.0, 5.0, 2; low_temp = 15000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L198-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat" href="#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat"><code>Newtman.SimulatedAnnealing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimulatedAnnealing(f::Benchmark, a::T, b::T, dim::Integer;
    t0 = 500.0, low_temp = 5000) where {T &lt;: AbstractFloat} -&gt; OptimizationResults</code></pre><p>Same implementation as the one for <a href="#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Benchmark,T,T,Integer}} where T&lt;:AbstractFloat"><code>SimulatedAnnealing</code></a> except that this one can accept <code>Benchmark</code> functions implemented within <code>Newtman.TestFunctions</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Implement Simulated Annealing for a 3-dimensional Rosenbrock function, with
# 10000 iterations.
val = SimulatedAnnealing(Rosenbrock(), -5.0, 5.0, 3; low_temp = 10000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L10-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat" href="#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T&lt;:AbstractFloat"><code>Newtman.SimulatedAnnealing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimulatedAnnealing(f::Function, a::T, b::T, dim::Integer;
    t0 = 500.0, low_temp = 5000, seed = nothing
    ) where {T &lt;: AbstractFloat} -&gt; OptimizationResults</code></pre><p>Implementation of the <em>classical</em> version of simulated annealing. This implementation uses a logarithmic cooling schedule and searches possible candidate solutions by sampling from an approximate Boltzmann distribution, drawn as a normal distribution.</p><p>Returns an <code>OptimizationResults</code> type with information relevant to the run executed, see <a href="#Newtman.OptimizationResults"><code>OptimizationResults</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: any user defined <code>Function</code> that can take <code>AbstractArray</code>&#39;s.</li><li><code>a</code>: <strong>lower</strong> bound for the solution search space.</li><li><code>b</code>: <strong>upper</strong> bound for the solution search space.</li><li><code>dim</code>: dimension of the optimization problem.</li></ul><p><strong>Keyword arguments</strong></p><p><em>It is recommended to use the default values provided.</em></p><ul><li><code>t0</code>: initial value for the <em>temperature</em> that is used. The default is an okay</li></ul><p>value, but should be changed depending on the optimization problem.</p><ul><li><code>low_temp</code>: total number of iterations, short for <em>lowering temperature steps</em>.</li></ul><p>This also corresponds to the famous <em>Monte Carlo steps</em>, which are the total number of steps until the algorithm finishes.</p><ul><li><code>seed</code>: an integer to be used as the seed for the pseudo random number generators.</li></ul><p>If <code>nothing</code> is passed (the default), then a random seed will be taken from the system.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Newtman

# Define the 2D Rosenbrock function
rosenbrock2d(x) =  (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2

# Implement Simulated Annealing for a 2-dimensional Rosenbrock function, with
# 5000 iterations.
val = SimulatedAnnealing(rosenbrock2d, -5.0, 5.0, 2; low_temp = 5000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L40-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman._gammaln-Tuple{AbstractFloat}" href="#Newtman._gammaln-Tuple{AbstractFloat}"><code>Newtman._gammaln</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the logarithm of the Gamma function as defined in the 3rd edition of Numerical Recipes in C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L375-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman._general_temperature!-Tuple{AbstractFloat,AbstractFloat}" href="#Newtman._general_temperature!-Tuple{AbstractFloat,AbstractFloat}"><code>Newtman._general_temperature!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A generalized cooling schedule that should work for every possible type of Simulated Annealing implementation. When <code>q</code> = 1, this reduces to the classical version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman._general_visit-Tuple{AbstractArray,AbstractArray,AbstractFloat,AbstractFloat,Any}" href="#Newtman._general_visit-Tuple{AbstractArray,AbstractArray,AbstractFloat,AbstractFloat,Any}"><code>Newtman._general_visit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is the algorithm from Tsallis &amp; Stariolo to sample the distribution shown in their paper, by approximating their probability distribution as a Lévy probability distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/solvers/simulated_annealing.jl#L301-L305">source</a></section></article><h2 id="Population"><a class="docs-heading-anchor" href="#Population">Population</a><a id="Population-1"></a><a class="docs-heading-anchor-permalink" href="#Population" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Newtman.Individual" href="#Newtman.Individual"><code>Newtman.Individual</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Individual</code></pre><p>Abstract super-type for types that contain their own information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/population/types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray" href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray"><code>Newtman.Particle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Particle(x::T, v::T, x_best::T, a::V, b::V)
    where {T&lt;:AbstractArray, V&lt;:AbstractFloat}</code></pre><p>A type that can hold information about current position, current velocity, the <em>best</em> candidate to a solution, as well as defining the bounds. The dimensions of the <code>Particle</code> are inferred from the length of the arrays.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Array that holds the <strong>positions</strong> of possible solutions.</li><li><code>v</code>: Array that holds <strong>velocities</strong> related to <code>x</code>.</li><li><code>x_best</code>: An element of <code>x</code> that determines the best position for the particle.</li><li><code>a</code>: lower bound for <code>x</code></li><li><code>b</code>: upper bound for <code>v</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">p = Particle(zeros(3), rand(3), zeros(3), -1.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/population/types.jl#L24-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V&lt;:Int64 where T&lt;:AbstractFloat" href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V&lt;:Int64 where T&lt;:AbstractFloat"><code>Newtman.Particle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Particle(a::T, b::T, n::V)
    where {T&lt;:AbstractFloat, V&lt;:Int}</code></pre><p><code>Particle</code> that can be created randomly using the bounds and the dimension needed.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: lower bound for <code>x</code></li><li><code>b</code>: upper bound for <code>v</code></li><li><code>n</code>: dimension for <code>x</code>, <code>v</code>, and <code>x_best</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">p = Particle(-1.0, 1.0, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/population/types.jl#L47-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}" href="#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}"><code>Newtman.Population</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Population(num_particles::Integer, dim::Integer, x...)
    -&gt; Vector{Particle}(undef, num_particles)</code></pre><p>An array of <code>Particle</code>&#39;s where each of them are bounded and are given a dimension. <code>x</code> is a tuple of ranges for each <em>dimension</em> for the <code>Particle</code>&#39;s specified.</p><p><strong>Arguments</strong></p><ul><li><code>num_particles</code>: Number of particles in the <code>Population</code>.</li><li><code>dim</code>: Dimension for every <code>Particle</code>.</li><li><code>x</code>: Tuple of ranges for each dimension.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># Two ranges, one for each dimension
range_a = SVector(-10.0, 10.0)
range_b = SVector(-2.5, 2.0)
pops = Population(2, 20, ranges_a, range_b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/population/types.jl#L115-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64" href="#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64"><code>Newtman.Population</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Population(num_particles::T, dim::T, a::V, b::V)
    where {T&lt;:Int, V&lt;:AbstractFloat} -&gt; Vector{Particle}(undef, num_particles)</code></pre><p>An array of <code>Particle</code>s where each of them are bounded and are given a dimension. This is essentially a multi-dimensional array. It makes handling <code>Particle</code>s much easier.</p><p><strong>Arguments</strong></p><ul><li><code>num_particles</code>: Number of particles in the <code>Population</code>.</li><li><code>dim</code>: Dimension for every <code>Particle</code>.</li><li><code>a</code>: Lower bound for every <code>Particle</code>, this is shared across every instance.</li><li><code>b</code>: Upper bound for every <code>Particle</code>, this is shared across every instance.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">pop = Population(35, 4, -1.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/fafbfbcd834537733bae0a2cfad5285bd44051e7/src/population/types.jl#L83-L100">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">« Benchmark functions</a><a class="docs-footer-nextpage" href="../license/">License »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 10 July 2020 23:34">Friday 10 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
