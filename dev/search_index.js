var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmark-test-functions-1","page":"Benchmark functions","title":"Benchmark test functions","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The following benchmark functions are implemented, each function is defined in the survey[1]:","category":"page"},{"location":"benchmarks/#[Sphere](@ref)-1","page":"Benchmark functions","title":"Sphere","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The Sphere function is defined as:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx) = sum_i=1^d x_i^2","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"with d the dimension of the design vector mathbfx, subject to 0 leq x_i leq 10.","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The minimum is","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx^*) = 0 quad mathbfx^* = (0 cdots 0)","category":"page"},{"location":"benchmarks/#[Easom](@ref)-1","page":"Benchmark functions","title":"Easom","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The Easom function is defined as:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx) = -cos(x_1) cos(x_2) exp-(x_1 - pi)^2 - (x_2 - pi)^2","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"where the design vector is a 2-D vector only, subject to -100 leq x_i leq 100.","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The function has the following minimum:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx^*) = -1 quad mathbfx^* = (pi pi)","category":"page"},{"location":"benchmarks/#[Ackley](@ref)-1","page":"Benchmark functions","title":"Ackley","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The Ackley function is defined as:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx) = -20 expleft -002 sqrtfrac1dsum_i=1^dx_i^2 right\n- expleftfrac1dsum_i=1^dcos(2 pi x_i)right + 20 + e","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"where the design vector is a d-dimensional vector, subject to -35 leq x_i leq 35.","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The function has the following minimum:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx^*) = 0 quad mathbfx^* = (0 cdots 0)","category":"page"},{"location":"benchmarks/#[Rosenbrock](@ref)-1","page":"Benchmark functions","title":"Rosenbrock","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The famous Rosenbrock function is defined as:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx) = sum_i=1^N-1 left100(x_i-1-x_i^2)^2 +(1-x_i)^2 right","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"where the design vector is a N-dimensional vector, subject to -infty leq x_i leq infty.","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"The function has the following minimum:","category":"page"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"f(mathbfx^*) = 0 quad mathbfx^* = (1 cdots 1)","category":"page"},{"location":"benchmarks/#References-1","page":"Benchmark functions","title":"References","text":"","category":"section"},{"location":"benchmarks/#","page":"Benchmark functions","title":"Benchmark functions","text":"[1]: Jamil, M., & Yang, X. S. (2013). A literature survey of benchmark functions for global optimisation problems. International Journal of Mathematical Modelling and Numerical Optimisation, 4(2), 150–194. https://doi.org/10.1504/IJMMNO.2013.055204","category":"page"},{"location":"guide/#Reach-1","page":"Guide","title":"Reach","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"This package should/could be used by:","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Practitioners: people in need of a black box optimization framework for when they know very little about the problem at hand.\nStudents: wanting to learn about nature-inspired algorithms, stochastic optimization or want a general survey of the current literature.\nResearchers: who want to employ different algorithms at once, test them or use them as comparison for their own developed algorithms.","category":"page"},{"location":"guide/#Examples-1","page":"Guide","title":"Examples","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Using Newtman.jl is fairly straightforward, first you define your own function to minimize, in this case we will use a popular function, the Griewank function defined as","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"f(mathbfx) = sum_i=1^d fracx_i^24000 - prod_i=1^d cosleft( fracx_isqrtiright) + 1","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"where d is the dimension of the problem. It's mostly evaluated within the boundaries -100 leq x_i leq 100, and it has a minimum at mathbfx^* = (0 cdots 0), and it evaluates to f(mathbfx^*) = 0.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"We define the function in Julia like this","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"function griewank(x)\n    first_term = sum(x .^ 2) / 4000\n    # This variable will hold the result of the product,\n    # the second term in the function definition from above\n    second_term = 1.0\n    for (idx, val) in enumerate(x)\n        second_term *= cos(val / sqrt(idx))\n    end\n\n    return first_term - second_term + 1.0\nend","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Now, we wish to find the minimum of this function, and fortunately we know the true value so we can compare it later, we can use some of the implementations from Newtman.jl, for example, PSO:","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"using Newtman\n\nval = PSO(griewank, Population(30, 20, -100.0, 100.0), 20000)","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"In this script we have chosen 30 particles within the population, d is equal to 20, next we define the boundaries and finally we declare that the algorithm will run for 20000 maximum iterations until it stops, having converged.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"When run, the above script will output something similar, but not equal to the following","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Results from Optimization\n        Algorithm: PSO\n        Design: [-3.0934433331801374e-9, -9.001706531841356e-9, 6.040569693490043e-9,\n        3.651856870710123e-9, 1.7717846067288837e-8, -9.72251672565314e-9,\n        -8.67994652424922e-10, -1.3340012700350453e-8, -6.538523861855145e-9,\n        1.1096356317905482e-8, -3.0867381867588525e-8, 2.2709162725331985e-8,\n        -2.359195570178852e-8, 1.2443005116661222e-8, 7.034134730754994e-10,\n        2.6289422248296343e-8, -1.6855112446841584e-8, 2.5996179394073387e-8,\n        -3.470098659476618e-8, 1.380018538766239e-8]\n        Minimum: 0.0000\n        Maximum iterations: 20000","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Within a certain tolerance of about \\epsilon = 1e-8 we have found the true minimum of the function. We can actually check the value with the evaluation, notice that it actually returns 0, as expected.","category":"page"},{"location":"guide/#A-primer-on-numerical-optimization-1","page":"Guide","title":"A primer on numerical optimization","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Optimization is a huge subject, and I don't think Newton even realized this when discovering Calculus, where optimization has its roots. Basically, in optimization we are trying to find the best possible solution to a given problem. Worded in this way it seems that optimization is actually everywhere we look around, which is so very true, optimization is everywhere!","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Say you like to run, and you look at your milage, timings and so on; you start to wonder, what is the best way to improve my timings? How can I maximize it?","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Now imagine that you have some money to spare and you wish to invest it. What type of investment will return the largest profit and will also minimize the possible risk of losing money?","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Optimization has been a major subject within analysis, the major branch of mathematics where most of its arguments come from. In mathematical language, we define an optimization problem as follows","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"textminimize f(mathbfx) quad mathbfx in mathbbR \ntextsubject to  h(mathbfx) = 0 \ntextand g(mathbfx) leq 0 \n\n\n","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"h and g are referred to as constraint functions, and the full expressions with their equalities and inequalities are simply called constraints. When we have a problem like this, we call this a constrained optimization problem.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"On the other hand, if we only define the problem as","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"textminimize f(mathbfx)quad mathbfx in mathbbR","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"we are talking about an unconstrained optimization problem.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"The goal of optimization is to find the vector \\mathbf{x} that gives the lowest possible value for f given all the constraints, if any. The classic way to achieve this is by using derivatives and derivative tests, and throughout the years mathematicians have developed very rigorous and robust algorithms to find these values. Almost every procedure uses derivatives because Newton and Gauss taught us that these converge faster and more precisely to the true values. But recently, stochastic optimization algorithms, were randomness is used to guide the search for the best value, have been very popular and widely used within the scientific community.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"This is a very, very small space to talk about optimization, but the following references should get you started right away. [1], [2] and [3].","category":"page"},{"location":"guide/#On-Convergence-1","page":"Guide","title":"On Convergence","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Convergence is a very strong word in mathematics, and it actually has lots of definitions depending on the specific branch of mathametics it is used. Here we shall use the numerical analysis definition, which is simply stated as a limit. We wish to obtain a value, whatever it is, in a finite time.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"We may employ tolerance values where we argue that a given solution is close to the real value that I know of. We can see this in the example above, where we know that the true value is a vector filled with zeros, but we don't actually obtain zeros, instead we get close values to zeros within a certain tolerance: in this scenario we can say that the optimization algorithm has converged.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"If, on the other hand, we rely on the number of maximum iterations then we can safely claim that when the algorithm has run for the number of maximum iterations then it has converged. Is that so? At least, in the realm of approximation algorithms we can safely claim that this is true.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"But don't take my word for it, in reality this is a very serious mathematical topic and should not be taken so slightly. Actually, every algorithm ever implemented must have a convergence analysis carried out for it, to ensure that either it will stop at some time or that it will given the desired result.","category":"page"},{"location":"guide/#The-basics-of-nature-and-bio-inspired-metaheuristics-1","page":"Guide","title":"The basics of nature and bio-inspired metaheuristics","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Nature and bio-inspired metaheuristics work by means of two fundamental heuristics: exploration and exploitation.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"First, exploration is leveraged through the use of random numbers, these are created to try to cover most of the search space, i.e. the set of possible values that can be considered the solution to a given optimization problem. When exploring the search space, metaheuristics try to search as efficiently as possible, and most algorithms use uniform sampling to try and cover most, if not all, of the search space.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Once the search space has been explored, the algorithm tries to identify, by means of some update rule, which of these proposed solutions are actually valid. In swarm intelligence algorithms such as Particle Swarm Optimization the different particles are ranked and checked against each other to see which has the most promising value. Then, exploitation kicks in, trying to take advantage of this information and trying to pull most of the swarm towards it.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"In the topic of optimization algorithms, nature and bio-inspired metaheuristics have a special place when talking about convergence, stability, and significance.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"First, convergence is usually measured as described in the section above, by means of a tolerance or a maximum number of iterations.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"Stability is a harder topic in this matter, because of the random aspect of most, if not all, of the current popular nature and bio-inspired metaheuristics. Reproduciblity is a big factor, and almost always algorithms need to be run independently at least 30 different times, with 30 statistically independent random number generators. But even this won't guarantee that every single run will give a good solution to the problem.","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"At last, statistical significance is almost mandatory if one wants to have a solution that has an actual mathematical and statistical meaning. Because of randomness, the actual mechanism by which nature and bio-inspired metaheuristics are Markov Chains [4] which provide statistical tools to guarantee and promise that the values found are, indeed, the real ones. Hypothesis tests like the parametric t-test, the Mann-Whitney-Wilcoxon non-parametric test, and some others are the most popular statistical tests to prove significance of the values obtained from applying nature and bio-inspired metaheuristics.","category":"page"},{"location":"guide/#References-1","page":"Guide","title":"References","text":"","category":"section"},{"location":"guide/#","page":"Guide","title":"Guide","text":"[4]: Yang, X.-S. (2014). Nature-inspired optimization algorithms. In Elsevier Insights. https://doi.org/10.1007/978-981-10-6689-4_8","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"[1]: https://en.wikipedia.org/wiki/Mathematical_optimization#History","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"[2]: https://web.stanford.edu/group/sisl/k12/optimization/MO-unit1-pdfs/1.1optimization.pdf","category":"page"},{"location":"guide/#","page":"Guide","title":"Guide","text":"[3]: https://sites.math.northwestern.edu/~clark/publications/opti.pdf","category":"page"},{"location":"license/#","page":"License","title":"License","text":"Newtman.jl was created by Edwin Bedolla and the package can be used with the following license:","category":"page"},{"location":"license/#","page":"License","title":"License","text":"Copyright (c) 2019 Edwin BedollaPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Benchmarks-1","page":"Reference","title":"Benchmarks","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [Newtman]\nPages = [\"functions.jl\",\n        \"implementations.jl\"]","category":"page"},{"location":"reference/#Newtman.Ackley","page":"Reference","title":"Newtman.Ackley","text":"Ackley\n\nAn unconstrained implementation of the d-dimensional Ackley function defined as:\n\nf(mathbfx) = -20 e^ -002 sqrtfrac1dsum_i=1^dx_i^2 - e^frac1dsum_i=1^dcos(2 pi x_i) + 20 + e\n\nwhere d is the dimension of the input vector mathbfx.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Easom","page":"Reference","title":"Newtman.Easom","text":"Easom\n\nAn unconstrained implementation of the 2-dimensional Easom function defined as:\n\nf(mathbfx) = -cos(x_1) cos(x_2) exp-(x_1 - pi)^2 - (x_2 - pi)^2\n\nwhere x_1 and x_2 refer to the first and second element of the input vector mathbfx.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Rosenbrock","page":"Reference","title":"Newtman.Rosenbrock","text":"Rosenbrock\n\nAn unconstrained implementation of the d-dimensional Rosenbrock function defined as:\n\nf(mathbfx) = sum_i=1^N-1 left100(x_i-1-x_i^2)^2 +(1-x_i)^2 right\n\nwhere N is the dimension of the input vector mathbfx.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Sphere","page":"Reference","title":"Newtman.Sphere","text":"Sphere\n\nAn unconstrained implementation of the Sphere function defined as:\n\nf(mathbfx) = sum_i=1^d x_i^2\n\nwhere d is the dimension of the input vector mathbfx.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.TestFunctions","page":"Reference","title":"Newtman.TestFunctions","text":"TestFunctions\n\nAbstract supertype for all benchmark functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Unconstrained","page":"Reference","title":"Newtman.Unconstrained","text":"Unconstrained\n\nAbstract supertype for all unconstrained benchmark functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Algorithms-1","page":"Reference","title":"Algorithms","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [Newtman]\nPages = [\"solvers/solvers.jl\", \"solvers/pso.jl\", \"solvers/simulated_annealing.jl\"]","category":"page"},{"location":"reference/#Newtman.Metaheuristic","page":"Reference","title":"Newtman.Metaheuristic","text":"Metaheuristic\n\nAbstract type for metaheuristic algorithms, this makes a clear distinction between different classifications of metaheuristic algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.OptimizationResults","page":"Reference","title":"Newtman.OptimizationResults","text":"OptimizationResults{T, U, V, W}\n\nType that formats the output of Solver to get better information from it.\n\nFields\n\nx::T: Stores the solution array from the solver, i.e. the solution that minimizes   the cost function.\nmin::U: Stores the value obtained from evaluating the cost function with   x, i.e. the minima found.\nimpl::AbstractString: Stores the name of the Solver used, i.e. the name or identifier of the   optimization algorithm.\niterations::Integer: Stores the number of maximum iterations that the solver was run.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.PopulationBase","page":"Reference","title":"Newtman.PopulationBase","text":"PopulationBase\n\nType for population-based algorithms that employ Population, i.e. subroutines that mutate an array of possible candidates in-place. An example of this type is PSO.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.PSO","page":"Reference","title":"Newtman.PSO","text":"PSO\n\nPSO is the type associated with the implementation for the Particle Swarm Optimization with momentum. See Algorithms for more information.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.PSO-Tuple{Function,AbstractArray,Int64}","page":"Reference","title":"Newtman.PSO","text":"PSO(f::Function, population::AbstractArray, k_max::Int;\n    w=0.9, c1=2.0, c2=2.0) -> OptimizationResults\n\nMethod that implements PSO for a function f of type Function, or of type TestFunctions. Returns an OptimizationResults type with information relevant to the run executed, see OptimizationResults.\n\nArguments\n\npopulation: can be any AbstractArray that contains Particle\n\ninstances, but it is expected to be generated by Population.\n\nk_max: number of maximum iterations until \"convergence\" of the algorithm.\n\nKeyword arguments\n\nIt is recommended to use the default values provided.\n\nw: value that controls how much of the initial velocity is retained, i.e.\n\nan inertia term. This values decays linearly over each iteration until it reaches the default miminum value of 0.4.\n\nc1: balance between the influence of the individual's knowledge, i.e. the\n\nbest inidividual solution so far.\n\nc2: balance between the influence of the population's knowledge, i.e. the\n\nbest global solution so far.\n\nExamples\n\nFor Functions\n\nusing Newtman\n\n# Define the Sphere function\nf_sphere(x) = sum(x .^ 2)\n\n# Implement PSO for a 3-dimensional Sphere function, with\n# 10000 iterations and 30 particles in the population.\nval = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000)\n\nFor TestFunctions\n\nusing Newtman\n\n# Implement PSO for a 3-dimensional Sphere function, with\n# 10000 iterations and 25 particles in the population.\nval = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Function,T,T,Integer}} where T<:AbstractFloat","page":"Reference","title":"Newtman.SimulatedAnnealing","text":"SimulatedAnnealing(f::Function, a::T, b::T, dim::Integer;\n    t0 = 500.0, low_temp = 5000) where {T <: AbstractFloat} -> OptimizationResults\n\nImplementation of the classical version of simulated annealing. This implementation uses a logarithmic cooling schedule and searches possible candidate solutions by sampling from an approximate Boltzmann distribution, drawn as a normal distribution.\n\nReturns an OptimizationResults type with information relevant to the run executed, see OptimizationResults.\n\nArguments\n\nf: any user defined Function that can take AbstractArray's.\na: lower bound for the solution search space.\nb: upper bound for the solution search space.\ndim: dimension of the optimization problem.\n\nKeyword arguments\n\nIt is recommended to use the default values provided.\n\nt0: initial value for the temperature that is used. The default is an okay\n\nvalue, but should be changed depending on the optimization problem.\n\nlow_temp: total number of iterations, short for lowering temperature steps.\n\nThis also corresponds to the famous Monte Carlo steps, which are the total number of steps until the algorithm finishes.\n\nExamples\n\nusing Newtman\n\n# Define the 2D Rosenbrock function\nrosenbrock2d(x) =  (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\n\n# Implement Simulated Annealing for a 2-dimensional Rosenbrock function, with\n# 5000 iterations.\nval = SimulatedAnnealing(rosenbrock2d, -5.0, 5.0, 2; low_temp = 5000)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.SimulatedAnnealing-Union{Tuple{T}, Tuple{Newtman.TestFunctions,T,T,Integer}} where T<:AbstractFloat","page":"Reference","title":"Newtman.SimulatedAnnealing","text":"SimulatedAnnealing(f::TestFunctions, a::T, b::T, dim::Integer;\n    t0 = 500.0, low_temp = 5000) where {T <: AbstractFloat} -> OptimizationResults\n\nSame implementation as the one for SimulatedAnnealing except that this one can accept TestFunctions functions implemented within Newtman.\n\nExamples\n\nusing Newtman\n\n# Implement Simulated Annealing for a 3-dimensional Rosenbrock function, with\n# 10000 iterations.\nval = SimulatedAnnealing(Rosenbrock(), -5.0, 5.0, 3; low_temp = 10000)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Solver","page":"Reference","title":"Newtman.Solver","text":"Solver\n\nAbstract super-type for every algorithm implementation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman._clip_positions_velocities!-Tuple{Any}","page":"Reference","title":"Newtman._clip_positions_velocities!","text":"Apply boundary conditions to both position and velocity for every Particle type object P.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman._create_rng-Tuple{}","page":"Reference","title":"Newtman._create_rng","text":"Returns num_rngs number of statistically independent pseudo-random number generators by creating a master RNG and drawing numbers from it, these numbers will serve as seeds for the number of RNG's returned in the form of an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman._weight_decay-Tuple{Any,Any}","page":"Reference","title":"Newtman._weight_decay","text":"Compute the corresponding weight decay depending the maximum number of iterations and the initial value for it.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman._classical_visit-Tuple{AbstractArray,AbstractArray,AbstractFloat,Any}","page":"Reference","title":"Newtman._classical_visit","text":"This scheme approximates a Boltzmann distribution\n\np_i = frace^-varepsilon_ikTsum_j e^-varepsilon_jkT\n\nwhere k is the Boltzmann constant, T is the temperature, and varepsilon is the energy at state i.\n\nThe approximation is done by means of a standard normal distribution like so\n\np_i sym mathcalN(0 sqrtT)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Population-1","page":"Reference","title":"Population","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [Newtman]\nPages = [\"population/types.jl\"]","category":"page"},{"location":"reference/#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V<:AbstractFloat where T<:AbstractArray","page":"Reference","title":"Newtman.Particle","text":"Particle(x::T, v::T, x_best::T, a::V, b::V)\n    where {T<:AbstractArray, V<:AbstractFloat}\n\nA type that can hold information about current position, current velocity, the best candidate to a solution, as well as defining the bounds. The dimensions of the Particle are inferred from the length of the arrays.\n\nArguments\n\nx: Array that holds the positions of possible solutions.\nv: Array that holds velocities related to x.\nx_best: An element of x that determines the best position for the particle.\na: lower bound for x\nb: upper bound for v\n\nExample\n\np = Particle(zeros(3), rand(3), zeros(3), -1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V<:Int64 where T<:AbstractFloat","page":"Reference","title":"Newtman.Particle","text":"Particle(a::T, b::T, n::V)\n    where {T<:AbstractFloat, V<:Int}\n\nParticle that can be created randomly using the bounds and the dimension needed.\n\nArguments\n\na: lower bound for x\nb: upper bound for v\nn: dimension for x, v, and x_best.\n\nExample\n\np = Particle(-1.0, 1.0, 3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Population-Tuple{Integer,Integer,Vararg{Any,N} where N}","page":"Reference","title":"Newtman.Population","text":"Population(num_particles::Integer, dim::Integer, x...)\n    -> Vector{Particle}(undef, num_particles)\n\nAn array of Particle's where each of them are bounded and are given a dimension. x is a tuple of ranges for each dimension for the Particle's specified.\n\nArguments\n\nnum_particles: Number of particles in the Population.\ndim: Dimension for every Particle.\nx: Tuple of ranges for each dimension.\n\nExample\n\n# Two ranges, one for each dimension\nrange_a = SVector(-10.0, 10.0)\nrange_b = SVector(-2.5, 2.0)\npops = Population(2, 20, ranges_a, range_b)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V<:AbstractFloat where T<:Int64","page":"Reference","title":"Newtman.Population","text":"Population(num_particles::T, dim::T, a::V, b::V)\n    where {T<:Int, V<:AbstractFloat} -> Vector{Particle}(undef, num_particles)\n\nAn array of Particles where each of them are bounded and are given a dimension. This is essentially a multi-dimensional array. It makes handling Particles much easier.\n\nArguments\n\nnum_particles: Number of particles in the Population.\ndim: Dimension for every Particle.\na: Lower bound for every Particle, this is shared across every instance.\nb: Upper bound for every Particle, this is shared across every instance.\n\nExample\n\npop = Population(35, 4, -1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Individual","page":"Reference","title":"Newtman.Individual","text":"Individual\n\nAbstract super-type for types that contain their own information.\n\n\n\n\n\n","category":"type"},{"location":"#Newtman.jl-1","page":"Home","title":"Newtman.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is Newtman.jl, an stochastic optimization package that implements a number of metaheuristic algorithms, mostly nature-inspired and bio-inspired.","category":"page"},{"location":"#On-Metaheuristics-1","page":"Home","title":"On Metaheuristics","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The term metaheuristic has some history behind it, and a large span of definitions within the scientific community. In Newtman.jl, metaheuristic is defined as follows","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A metaheuristic is a black box optimization framework that employs heuristics to find a close-to optimal solution for a given optimization problem.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The definition is important in this context. Newtman.jl strives on implementations of already existent algorithms, but actually the term itself has not yet been acquired a formal definition, as Sörensen[1] says in his paper.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Because Newtman.jl employs metaheuristics as actual black box optimization frameworks, this definition should be enough to provide the actual purpose of the package.","category":"page"},{"location":"#Nature-and-bio-inspired-algorithms-1","page":"Home","title":"Nature and bio-inspired algorithms","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Heuristic is a term for a simple rule. Given a rule, mainly provided by experience, one can create a process or algorithm to solve a given problem.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Nature is an unlimited source of experience that can provide a lot of heuristics for us, if one looks closely.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Recent research has taken this approach[2] and scientists have taken inspiration from nature to create heuristics for problem solving. Examples are Ant Colony Optimization[3], based on the foraging behavior of ant colonies, Particle Swarm Optimization[4], which draws inspiration in the so-called swarm intelligence of birds, people, and so on.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With this mindset, the field of stochastic optimization witnessed an avalanche of \"novel\" algorithms all based on nature, which were called nature-inspired metaheuristics.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If one takes not only nature, but physics, chemistry and biology, one can create the so-called bio-inspired metaheuristics, based on ideas drawn from biological, chemical and physical processes.","category":"page"},{"location":"#The-need-for-Newtman.jl-and-nature-inspired-algorithms-1","page":"Home","title":"The need for Newtman.jl and nature-inspired algorithms","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Most metaheuristic algorithms are not very difficult to implement, and most of the time there is already a package for it (e.g. NiaPy for Python).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In general, these algorithms are not consistently used because there are more robust and exact algorithms out there, such as the classics BFGS, L-BFGS, Gradient Descent and many more.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Nonetheless, there are several areas in optimization that need quick and approximate solutions, mostly because they are unsolvable in finite time[1]. Because of this, nature and bio-inspired algorithms rose to the top in some of these problems and were the only framework that could give a reasonable solution.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"When there is not much information about the problem (i.e. the derivative or gradient of the fitness function), or if the classic algorithms take too much time to converge, nature and bio-inspired algorithms tackle these types of problems with randomness and heuristics, and having found a close-to optimal solution, more robust algorithms can be applied to the given problem. [5]","category":"page"},{"location":"#About-using-Julia-1","page":"Home","title":"About using Julia","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In scientific computing, the Julia programming language has been an excellent tool to get rid of the two language problem, i.e. when there is a need for high perfomance calculations but with low level manipulation, problems can be harder to code and even harder to solve. Julia is a great candidate to solve this problem, and this package attempts to prove that by providing high perfomant code and implementations.","category":"page"},{"location":"#The-Evolutionary-Computation-Bestiary-1","page":"Home","title":"The Evolutionary Computation Bestiary","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There is a hidden goal for Newtman.jl and that is to implement all of the algorithms proposed in the EC Bestiary[6], which is a compilation of most of the nature and bio-inspired algorithms in the literature.","category":"page"},{"location":"#On-the-name-of-the-package-1","page":"Home","title":"On the name of the package","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Because of this hidden goal, the name Newtman was chosen, which is a pormanteau of the character by J.K. Rowling, Newton Scamander, whose purpose in life is to collect samples of fantastic beasts and create a book or log of their nature.","category":"page"},{"location":"#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"[1]: Sörensen, K. (2015). Metaheuristics-the metaphor exposed. International Transactions in Operational Research, 22(1), 3–18. https://doi.org/10.1111/itor.12001","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[2]: Kar, A. K. (2016). Bio inspired computing - A review of algorithms and scope of applications. Expert Systems with Applications, 59, 20–32. https://doi.org/10.1016/j.eswa.2016.04.018","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[3]: Dorigo, M., & Di Caro, G. (1999, July). Ant colony optimization: a new meta-heuristic. In Proceedings of the 1999 congress on evolutionary computation-CEC99 (Cat. No. 99TH8406) (Vol. 2, pp. 1470-1477). IEEE.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[4]: Eberhart, R., & Kennedy, J. (1995, November). Particle swarm optimization. In Proceedings of the IEEE international conference on neural networks (Vol. 4, pp. 1942-1948).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[5]: Luke, S. (2011). Essentials of metaheuristics. In Genetic Programming and Evolvable Machines (Vol. 12). https://doi.org/10.1007/s10710-011-9139-0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[6]: Felipe Campelo, & Claus Aranha. (2018, June 20). EC Bestiary: A bestiary of evolutionary, swarm and other metaphor-based algorithms (Version v2.0.1). Zenodo. http://doi.org/10.5281/zenodo.1293352","category":"page"},{"location":"algorithms/#implementations-docs-1","page":"Implementations","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"The following algorithms are implemented:","category":"page"},{"location":"algorithms/#Particle-Swarm-Optimization-1","page":"Implementations","title":"Particle Swarm Optimization","text":"","category":"section"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"This implementation is the modified Particle Swarm Optimization [1] where it employs an inertia weight omega that controls convergence. This implementation uses linear decay for the inertia weight, which lowers the value of  omega iteratively until it reaches the default minimum of omega = 04.","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"The update rules for the particles are the following:","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"x_i+1 = x_i + v_i+1 \nv_i+1 = omega v_i + varphi_1 beta_1 (p_i - x_i) + varphi_2 beta_2 (p_g - x_i) \nomega = omega - eta","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"where beta_1 and beta_2 are uniformly distributed random numbers; varphi_1 and varphi_2 are the momentum coefficients; p_i is the previous individual best position and p_g is the privious global best position of the population; finally eta is the weight decay, currently implemented as","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"eta = frac(09 - 04)n","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"where 09 is the original default value for omega, 04 is the default minimum as explained before and n is the total number of iterations the algorithm is run. This guarantees that the weight decays linearly.","category":"page"},{"location":"algorithms/#Simulated-Annealing-1","page":"Implementations","title":"Simulated Annealing","text":"","category":"section"},{"location":"algorithms/#Classic-version-1","page":"Implementations","title":"Classic version","text":"","category":"section"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"This implementation [2] uses the following logarithmic cooling schedule","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"T_new(t) = T_0 fraclog(2)log1 + t","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"to obtain a new temperature each iteration, starting from an initial temperature T_0.","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"This implementation searches possible candidate solutions by sampling from an approximate Boltzmann distribution, drawn as a normal distribution like so","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"g_sol(x) = mathcalN(0 1) * sigma \nx_sol = x_prev + g_sol(x)","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"where g_sol(x) is an array filled with random values sampled from an approximate normal standard distribution with standard deviation sigma = sqrtT_new(t) which corresponds to the previously found temperature. With this array, the new solution is computed as the previous (best) solution, x_sol, and adding the sampled array.","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"Finally, the Metropolis-Hastings algorithm is defined as","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"P(x_sol leftarrow x_old) = 10 qquad f(x_sol)  f(x_old) \nP(x_sol leftarrow x_old) = e^(Delta  T_new(t)) qquad f(x_sol) geq f(x_old)","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"where Delta = f(x_old) - f(x_sol).","category":"page"},{"location":"algorithms/#References-1","page":"Implementations","title":"References","text":"","category":"section"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"[1]: Eberhart, R. C., & Shi, Y. (2000, July). Comparing inertia weights and constriction factors in particle swarm optimization. In Proceedings of the 2000 congress on evolutionary computation. CEC00 (Cat. No. 00TH8512) (Vol. 1, pp. 84-88). IEEE.","category":"page"},{"location":"algorithms/#","page":"Implementations","title":"Implementations","text":"[2]: C. Tsallis and D. A. Stariolo, “Generalized Simulated Annealing,” Physica A: Statistical Mechanics and its Applications, vol. 233, no. 1–2, pp. 395–406, Nov. 1996, doi: 10.1016/S0378-4371(96)00271-3.","category":"page"}]
}
