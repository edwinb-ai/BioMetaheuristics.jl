var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference-1","page":"Refence","title":"Reference","text":"","category":"section"},{"location":"reference/#Benchmarks-1","page":"Refence","title":"Benchmarks","text":"","category":"section"},{"location":"reference/#","page":"Refence","title":"Refence","text":"Modules = [Newtman]\nPages = [\"functions.jl\",\n        \"implementations.jl\"]","category":"page"},{"location":"reference/#Newtman.Easom","page":"Refence","title":"Newtman.Easom","text":"Easom\n\nAn unconstrained implementation of the 2-dimensional Easom function defined as:\n\nf(mathbfx) = -cos(x_1) cos(x_2) exp-(x_1 - pi)^2 - (x_2 - pi)^2\n\nwhere x_1 and x_2 refer to the first and second element of the input vector mathbfx.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Sphere","page":"Refence","title":"Newtman.Sphere","text":"Sphere\n\nAn unconstrained implementation of the Sphere function defined as:\n\nf(mathbfx) = sum_i=1^d x_i^2\n\nwhere d is the dimension of the input vector mathbfx.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.TestFunctions","page":"Refence","title":"Newtman.TestFunctions","text":"TestFunctions\n\nAbstract supertype for all benchmark functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Unconstrained","page":"Refence","title":"Newtman.Unconstrained","text":"Unconstrained\n\nAbstract supertype for all unconstrained benchmark functions.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Algorithms-1","page":"Refence","title":"Algorithms","text":"","category":"section"},{"location":"reference/#","page":"Refence","title":"Refence","text":"Modules = [Newtman]\nPages = [\"solvers/pso.jl\", \"solvers/solvers.jl\"]","category":"page"},{"location":"reference/#Newtman.PSO","page":"Refence","title":"Newtman.PSO","text":"PSO\n\nPSO is the type associated with the implementation for the Particle Swarm Optimization as implemented in the original paper by Kennedy and Eberhart.[1]\n\n[1]: Eberhart, R., & Kennedy, J. (1995, November). Particle swarm optimization. In Proceedings of the IEEE international conference on neural networks (Vol. 4, pp. 1942-1948).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.PSO-Tuple{Function,AbstractArray,Int64}","page":"Refence","title":"Newtman.PSO","text":"PSO(f::Function, population::AbstractArray, k_max::Int;\n    w=1.0, c1=1.0, c2=1.0)\n\nMethod that implements PSO for a function f of type Function.\n\nArguments\n\npopulation: can be any AbstractArray that contains Particle\n\ninstances, but it is expected to be generated by Population.\n\nk_max: number of maximum iterations until \"convergence\" of the algorithm.\n\nKeyword arguments\n\nw: value that controls how much of the initial velocity is retained, i.e.\n\nan inertia term.\n\nc1: balance between the influence of the individual's knowledge, i.e. the\n\nbest inidividual solution so far.\n\nc2: balance between the influence of the population's knowledge, i.e. the\n\nbest global solution so far.\n\nExamples\n\nusing Newtman\n\n# Define the Sphere function\nfunction f_sphere(x)\n    return sum(x .^ 2)\nend\n\n# Implement PSO for a 3-dimensional Sphere function, with\n# 100 iterations and 30 particles in the population.\nval = PSO(f_sphere, Population(25, 3, -15.0, 15.0), 45;\n    w=0.5, c1=0.25, c2=1.5)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.PSO-Tuple{Newtman.TestFunctions,AbstractArray,Int64}","page":"Refence","title":"Newtman.PSO","text":"PSO(f::TestFunctions, population::AbstractArray, k_max::Int;\n    w=1.0, c1=1.0, c2=1.0)\n\nMethod that implements PSO for a function f of type TestFunctions.\n\nArguments\n\npopulation: can be any AbstractArray that contains Particle\n\ninstances, but it is expected to be generated by Population.\n\nk_max: number of maximum iterations until \"convergence\" of the algorithm.\n\nKeyword arguments\n\nw: value that controls how much of the initial velocity is retained, i.e.\n\nan inertia term.\n\nc1: balance between the influence of the individual's knowledge, i.e. the\n\nbest inidividual solution so far.\n\nc2: balance between the influence of the population's knowledge, i.e. the\n\nbest global solution so far.\n\nExamples\n\nusing Newtman\n\n# Implement PSO for a 3-dimensional Sphere function, with\n# 100 iterations and 30 particles in the population.\nval = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 45;\n    w=0.5, c1=0.25, c2=1.5)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Metaheuristic","page":"Refence","title":"Newtman.Metaheuristic","text":"Metaheuristic\n\nAbstract type for metaheuristic algorithms, this makes a clear distinction between different classifications of metaheuristic algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.PopulationBase","page":"Refence","title":"Newtman.PopulationBase","text":"PopulationBase\n\nType for population-based algorithms that employ Population, i.e. subroutines that mutate an array of possible candidates in-place. An example of this type is PSO.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Newtman.Solver","page":"Refence","title":"Newtman.Solver","text":"Solver\n\nAbstract super-type for every algorithm implementation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Population-1","page":"Refence","title":"Population","text":"","category":"section"},{"location":"reference/#","page":"Refence","title":"Refence","text":"Modules = [Newtman]\nPages = [\"population/types.jl\"]","category":"page"},{"location":"reference/#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V<:AbstractFloat where T<:AbstractArray","page":"Refence","title":"Newtman.Particle","text":"Particle(x::T, v::T, x_best::T, a::V, b::V)\n    where {T<:AbstractArray, V<:AbstractFloat}\n\nA type that can hold information about current position, current velocity, the best candidate to a solution, as well as defining the bounds. The dimensions of the Particle are inferred from the length of the arrays.\n\nArguments\n\nx: Array that holds the positions of possible solutions.\nv: Array that holds velocities related to x.\nx_best: An element of x that determines the best position for the particle.\na: lower bound for x\nb: upper bound for v\n\nExample\n\np = Particle(zeros(3), rand(3), zeros(3), -1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V<:Int64 where T<:AbstractFloat","page":"Refence","title":"Newtman.Particle","text":"Particle(a::T, b::T, n::V)\n    where {T<:AbstractFloat, V<:Int}\n\nParticle that can be created randomly using the bounds and the dimension needed.\n\nArguments\n\na: lower bound for x\nb: upper bound for v\nn: dimension for x, v, and x_best.\n\nExample\n\np = Particle(-1.0, 1.0, 3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V<:AbstractFloat where T<:Int64","page":"Refence","title":"Newtman.Population","text":"Population(num_particles::T, dim::T, a::V, b::V)\n    where {T<:Int, V<:AbstractFloat} -> Vector{Particle}(undef, num_particles)\n\nAn array of Particles where each of them are bounded and are given a dimension. This is essentially a multi-dimensional array. It makes handling Particles much easier.\n\nArguments\n\nnum_particles: Number of particles in the Population.\ndim: Dimension for every Particle.\na: Lower bound for every Particle, this is shared across every instance.\nb: Upper bound for every Particle, this is shared across every instance.\n\nExample\n\npop = Population(35, 4, -1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,V,V}} where V<:AbstractFloat where T<:Int64","page":"Refence","title":"Newtman.Population","text":"Population(dim::T, a::V, b::V)\n    where {T<:Int, V<:AbstractFloat} -> Vector{Particle}(undef, num_particles)\n\nIf num_particles is not provided, it defaults to 5 Particles in the Population.\n\nArguments\n\ndim: Dimension for every Particle.\na: Lower bound for every Particle, this is shared across every instance.\nb: Upper bound for every Particle, this is shared across every instance.\n\nExample\n\npop = Population(4, -1.0, 1.0) # The same as Population(5, 4, -1.0, 1.0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Newtman.Individual","page":"Refence","title":"Newtman.Individual","text":"Individual\n\nAbstract super-type for types that contain their own information.\n\n\n\n\n\n","category":"type"},{"location":"#Newtman.jl-1","page":"Home","title":"Newtman.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is Newtman.jl, an stochastic optimization module that implements a number of metaheuristic algorithms, mostly based on randomness.","category":"page"}]
}
