"""
    PSO

`PSO` is the type associated with the implementation for the
Particle Swarm Optimization with momentum. See [`Algorithms`](@ref implementations-docs)
for more information.
"""
struct PSO <: PopulationBase end

"""
    PSO(f::Function, population::AbstractArray, k_max::Int;
        w=0.9, c1=2.0, c2=2.0) -> OptimizationResults

Method that implements `PSO` for a function `f` of type `Function`,
or of type `TestFunctions`.
Returns an `OptimizationResults` type with information relevant to the
run executed, see [`OptimizationResults`](@ref).

# Arguments

- `population`: can be any `AbstractArray` that contains [`Particle`](@ref)
instances, but it is expected to be generated by [`Population`](@ref).
- `k_max`: number of maximum iterations until "convergence" of the algorithm.

# Keyword arguments
_It is recommended to use the default values provided._

- `w`: value that controls how much of the initial velocity is retained, i.e.
an inertia term. This values decays linearly over each iteration until it reaches
the default miminum value of 0.4.
- `c1`: balance between the influence of the individual's knowledge, i.e. the
best inidividual solution so far.
- `c2`: balance between the influence of the population's knowledge, i.e. the
best global solution so far.

# Examples
- For `Function`s
```julia
using Newtman

# Define the Sphere function
f_sphere(x) = sum(x .^ 2)

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 30 particles in the population.
val = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000)
```
- For `TestFunctions`
```julia
using Newtman

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 25 particles in the population.
val = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000)
```
"""
function PSO(f::Function, population::AbstractArray, k_max::Int;
    w = 0.9, c1 = 2.0, c2 = 2.0)

    val = _pso!(f, population, k_max; w = w, c1 = c1, c2 = c2)

    optim_res = OptimizationResults(val,
                _evaluate_cost(f, val),
                "PSO",
                k_max)
    return optim_res
end

"""
    PSO(f::Function, population::AbstractArray,
        k_max::Int, total_iter::Int;w=0.9, c1=2.0, c2=2.0) ->
        OptimizationResultsParallel

Method that implements `PSO` for a function `f` of type `TestFunctions`
with multiple runs enabled in parallel. Using `@threads` to make an
embarrassingly parallel implementation to obtain results quicker.

# Arguments

- `population`: can be any `AbstractArray` that contains [`Particle`](@ref)
instances, but it is expected to be generated by [`Population`](@ref).
- `k_max`: number of maximum iterations until "convergence" of the algorithm.
- `total_iter`: number of maximum _experiments_ to run in parallel.

# Keyword arguments
_It is recommended to use the default values provided._

- `w`: value that controls how much of the initial velocity is retained, i.e.
an inertia term. This values decays linearly over each iteration until it reaches
the default miminum value of 0.4.
- `c1`: balance between the influence of the individual's knowledge, i.e. the
best inidividual solution so far.
- `c2`: balance between the influence of the population's knowledge, i.e. the
best global solution so far.

# Examples
- For `TestFunctions`
```julia
using Newtman

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations, 25 particles in the population and 50 independent runs,
# evaluated in parallel
val = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000, 50)
```
- For `Function`s
```julia
using Newtman

# Define the Sphere function
f_sphere(x) = sum(x .^ 2)

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations, 30 particles in the population and 50
# independent runs evaluated in parallel
val = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000, 50)
```
"""

function PSO(f::Function, population::AbstractArray,
    k_max::Int, total_iter::Int;w = 0.9, c1 = 2.0, c2 = 2.0)

    results = [zeros(length(population[1].x)) for i = 1:total_iter]
    @sync Threads.@threads for i = 1:total_iter
        results[i] = _pso!(f, deepcopy(population), k_max; w = copy(w), c1 = c1, c2 = c2)
    end

    mean_value, std_value = _mean_std_results(results, total_iter)

    optim_res = OptimizationResultsParallel(mean_value,
                std_value,
                _evaluate_cost(f, mean_value),
                "PSO",
                k_max,
                total_iter)

    return optim_res
end

function _pso!(f, population::AbstractArray, k_max::Int;
    w = 0.9, c1 = 2.0, c2 = 2.0)

    # Create the RNGs, statistically independent
    rng_list = _create_rng()

    # Obtain weight decay rate
    η = _weight_decay(w, k_max)

    # Evaluate initial costs
    dimension = length(population[1].x)
    x_best = similar(population[1].x_best)
    y_best = Inf
    for P in population
        y = _evaluate_cost(f, P.x)
        if y < y_best
            x_best[:] = P.x
            y_best = y
        end
    end

    # PSO main loop
    for k in 1:k_max
        _update!(f, population, w, c1, c2, dimension, x_best, y_best, rng_list)
        # Make the inertia weight decay over time
        w -= η
    end

    return population[1].x_best
end

function _update!(f, population, w, c1, c2, n, x_best, y_best, rng)

    for P in population
        r1 = rand(rng[1], n)
        r2 = rand(rng[2], n)
        # Evaluate velocity
        P.v = (w * P.v) + (c1 * r1 .* (P.x_best - P.x)) +
            (c2 * r2 .* (x_best - P.x))
        # Update position
        P.x += P.v
        # Apply boundary values to positions and velocities
        _clip_positions_velocities!(P)
        # Update values if they give lower cost
        y = _evaluate_cost(f, P.x)
        if y < y_best
            x_best[:] = P.x
            y_best = y
        end
        if y < _evaluate_cost(f, P.x_best)
            P.x_best[:] = P.x
        end
    end
end

function _weight_decay(initial, itr_max)
    # Following the references, the minimum is 0.4
    stop = 0.4
    step_size = (initial - stop) / itr_max

    return step_size
end

function _clip_positions_velocities!(P)
    # First the positions
    # upper bound
    broadcast!(x->x > P.max_dim ? P.max_dim : x, P.x, P.x)
    # lower bound
    broadcast!(x->x < P.min_dim ? P.min_dim : x, P.x, P.x)
    # Then the velocities
    # upper bound
    broadcast!(x->x > P.max_dim ? P.max_dim : x, P.v, P.v)
    # lower bound
    broadcast!(x->x < P.min_dim ? P.min_dim : x, P.v, P.v)
end

function _create_rng()
    # Create the RNG to create seeds
    rng_master = PCG.PCGStateOneseq()
    seed_list = [rand(rng_master, UInt64) for i = 1:2]
    rng_list = map(x->Xorshifts.Xorshift1024Star(x), seed_list)
    return rng_list
end

function _mean_std_results(values, num_max)
    mean_value = zeros(length(values[1]))
    for i in eachindex(values)
        mean_value .+= values[i]
    end
    mean_value /= num_max

    std_value = 0.0
    for i in eachindex(values)
        std_value = (values[i] .- mean_value).^2
    end
    std_value = sqrt(sum(std_value) / num_max)

    return mean_value, std_value
end
