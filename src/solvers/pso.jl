import Newtman.TestFunctions: Benchmark, evaluate

"""
    PSO

`PSO` is the type associated with the implementation for the
Particle Swarm Optimization with momentum. See [`Algorithms`](@ref implementations-docs)
for more information.
"""
struct PSO <: PopulationBase end

"""
    PSO(f::Function, population::AbstractArray, k_max::Int;
        w=0.9, c1=2.0, c2=2.0) -> OptimizationResults

Method that implements `PSO` for a function `f` of type `Function`,
or of type `TestFunctions`.
Returns an `OptimizationResults` type with information relevant to the
run executed, see [`OptimizationResults`](@ref).

# Arguments

- `population`: can be any `AbstractArray` that contains [`Particle`](@ref)
instances, but it is expected to be generated by [`Population`](@ref).
- `k_max`: number of maximum iterations until "convergence" of the algorithm.

# Keyword arguments

_It is recommended to use the default values provided._

- `w`: value that controls how much of the initial velocity is retained, i.e.
an inertia term. This values decays linearly over each iteration until it reaches
the default miminum value of 0.4.
- `c1`: balance between the influence of the individual's knowledge, i.e. the
best inidividual solution so far.
- `c2`: balance between the influence of the population's knowledge, i.e. the
best global solution so far.

# Examples
```julia
using Newtman

# Define the Sphere function
f_sphere(x) = sum(x .^ 2)

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 30 particles in the population.
val = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000)
```
"""
function PSO(f::Function, population::AbstractArray, k_max::Int;
    w = 0.9, c1 = 2.0, c2 = 2.0, seed = nothing)

    val = _pso!(f, population, k_max; w = w, c1 = c1, c2 = c2, seed = seed)

    optim_res = OptimizationResults(val,
                f(val),
                "PSO",
                k_max)
    return optim_res
end

"""
    PSO(f::Benchmark, population::AbstractArray, k_max::Int;
        w=0.9, c1=2.0, c2=2.0) -> OptimizationResults

Method that implements `PSO` for a function `f` of type `Benchmark`.
Same implementation as the one for `Function`'s.

# Examples
```julia
using Newtman

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 25 particles in the population.
val = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000)
```
"""
function PSO(f::Benchmark, population::AbstractArray, k_max::Int;
    w = 0.9, c1 = 2.0, c2 = 2.0, seed = nothing)

    val = _pso!(
        x->evaluate(f, x),
        population,
        k_max;
        w = w,
        c1 = c1,
        c2 = c2,
        seed = seed
    )

    optim_res = OptimizationResults(val,
                evaluate(f, val),
                "PSO",
                k_max)
    return optim_res
end

function _pso!(f, population::AbstractArray, k_max::Int;
    w = 0.9, c1 = 2.0, c2 = 2.0, seed = nothing)

    # Create the RNGs, statistically independent
    rng_list = _create_rng(; seed = seed)

    # Obtain weight decay rate
    η = _weight_decay(w, k_max)

    # Evaluate initial costs
    dimension = length(population[1].x)

    # Initialize container variables
    x_best = similar(population[1].x_best)
    y_best = Inf
    for P in population
        y = f(P.x)
        if y < y_best
            x_best[:] = P.x
            y_best = y
        end
    end

    # PSO main loop
    for k in 1:k_max
        _update!(f, population, w, c1, c2, dimension, x_best, y_best, rng_list)
        # Make the inertia weight decay over time
        w -= η
    end

    # Always return the first position as it contains the best possible
    # solution
    return population[1].x_best
end

function _update!(f, population, w, c1, c2, n, x_best, y_best, rng)

    for P in population
        r1 = rand(rng[1], n)
        r2 = rand(rng[2], n)
        # Evaluate velocity
        P.v = (w * P.v) + (c1 * r1 .* (P.x_best - P.x)) +
            (c2 * r2 .* (x_best - P.x))
        # Update position
        P.x += P.v
        # Apply boundary values to positions and velocities
        _clip_positions_velocities!(P)
        # Update values if they give lower cost
        y = f(P.x)
        if y < y_best
            x_best[:] = P.x
            y_best = y
        end
        if y < f(P.x_best)
            P.x_best[:] = P.x
        end
    end
end

""" Compute the corresponding weight decay depending the maximum
number of iterations and the initial value for it.
"""
function _weight_decay(initial, itr_max)
    # Following the references, the minimum is 0.4
    stop = 0.4
    step_size = (initial - stop) / itr_max

    return step_size
end

""" Apply boundary conditions to both position and velocity for
every `Particle` type object `P`.
"""
function _clip_positions_velocities!(P)
    # First the positions
    # upper bound
    broadcast!(x->x > P.max_dim ? P.max_dim : x, P.x, P.x)
    # lower bound
    broadcast!(x->x < P.min_dim ? P.min_dim : x, P.x, P.x)

    # Then the velocities
    # upper bound
    broadcast!(x->x > P.max_dim ? P.max_dim : x, P.v, P.v)
    # lower bound
    broadcast!(x->x < P.min_dim ? P.min_dim : x, P.v, P.v)
end

""" Returns `num_rngs` number of statistically independent pseudo-random
number generators by creating a master RNG and drawing numbers from it,
these numbers will serve as seeds for the number of RNG's returned in the form
of an `AbstractArray`.
"""
function _create_rng(;seed = nothing, num_rngs = 2)
    if isnothing(seed)
        # Create the RNG to create seeds
        rng_master = PCG.PCGStateOneseq()
        # From this RNG, create two seeds
        seed_list = [rand(rng_master, UInt64) for i = 1:num_rngs]
    else
        # From this RNG, create two seeds
        rng_master = Xorshifts.Xoroshiro128Plus(seed)
        seed_list = [rand(rng_master, UInt64) for i = 1:num_rngs]
    end

    # With these seeds, seed two new RNG's
    rng_list = map(Xorshifts.Xorshift1024Star, seed_list)

    return rng_list
end
