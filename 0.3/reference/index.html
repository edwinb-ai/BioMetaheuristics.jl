<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Newtman.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Newtman.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../guide/">Guide</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Benchmarks-1">Benchmarks</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li><li><a class="toctext" href="#Population-1">Population</a></li></ul></li><li><a class="toctext" href="../license/">License</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/edwinb-ai/Newtman.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Benchmarks-1" href="#Benchmarks-1">Benchmarks</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Easom" href="#Newtman.Easom"><code>Newtman.Easom</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Easom</code></pre><p>An unconstrained implementation of the 2-dimensional Easom function defined as:</p><div>\[f(\mathbf{x}) = -\cos{(x_1)} \cos{(x_2)} \exp{[-(x_1 - \pi)^2 - (x_2 - \pi)^2]}\]</div><p>where <span>$x_1$</span> and <span>$x_2$</span> refer to the first and second element of the input vector <span>$\mathbf{x}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/test-functions/implementations.jl#L20-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Sphere" href="#Newtman.Sphere"><code>Newtman.Sphere</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Sphere</code></pre><p>An unconstrained implementation of the Sphere function defined as:</p><div>\[f(\mathbf{x}) = \sum_{i=1}^{d} x_i^2\]</div><p>where <span>$d$</span> is the dimension of the input vector <span>$\mathbf{x}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/test-functions/implementations.jl#L3-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.TestFunctions" href="#Newtman.TestFunctions"><code>Newtman.TestFunctions</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TestFunctions</code></pre><p>Abstract supertype for all benchmark functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/test-functions/functions.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Unconstrained" href="#Newtman.Unconstrained"><code>Newtman.Unconstrained</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Unconstrained</code></pre><p>Abstract supertype for all unconstrained benchmark functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/test-functions/functions.jl#L8-L12">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.PSO" href="#Newtman.PSO"><code>Newtman.PSO</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PSO</code></pre><p><code>PSO</code> is the type associated with the implementation for the Particle Swarm Optimization with momentum. See <a href="../algorithms/#implementations-docs-1"><code>Algorithms</code></a> for more information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/pso.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.PSO-Tuple{Function,AbstractArray,Int64}" href="#Newtman.PSO-Tuple{Function,AbstractArray,Int64}"><code>Newtman.PSO</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PSO(f::Function, population::AbstractArray, k_max::Int;
    w=0.9, c1=2.0, c2=2.0) -&gt; OptimizationResults</code></pre><p>Method that implements <code>PSO</code> for a function <code>f</code> of type <code>Function</code>, or of type <code>TestFunctions</code>. Returns an <code>OptimizationResults</code> type with information relevant to the run executed, see <a href="#Newtman.OptimizationResults"><code>OptimizationResults</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>population</code>: can be any <code>AbstractArray</code> that contains <a href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray"><code>Particle</code></a></li></ul><p>instances, but it is expected to be generated by <a href="#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64"><code>Population</code></a>.</p><ul><li><code>k_max</code>: number of maximum iterations until &quot;convergence&quot; of the algorithm.</li></ul><p><strong>Keyword arguments</strong></p><p><em>It is recommended to use the default values provided.</em></p><ul><li><code>w</code>: value that controls how much of the initial velocity is retained, i.e.</li></ul><p>an inertia term. This values decays linearly over each iteration until it reaches the default miminum value of 0.4.</p><ul><li><code>c1</code>: balance between the influence of the individual&#39;s knowledge, i.e. the</li></ul><p>best inidividual solution so far.</p><ul><li><code>c2</code>: balance between the influence of the population&#39;s knowledge, i.e. the</li></ul><p>best global solution so far.</p><p><strong>Examples</strong></p><ul><li>For <code>Function</code>s</li></ul><pre><code class="language-julia">using Newtman

# Define the Sphere function
f_sphere(x) = sum(x .^ 2)

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 30 particles in the population.
val = PSO(f_sphere, Population(30, 3, -15.0, 15.0), 10000)</code></pre><ul><li>For <code>TestFunctions</code></li></ul><pre><code class="language-julia">using Newtman

# Implement PSO for a 3-dimensional Sphere function, with
# 10000 iterations and 25 particles in the population.
val = PSO(Sphere(), Population(25, 3, -15.0, 15.0), 10000)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/pso.jl#L10-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._clip_positions_velocities!-Tuple{Any}" href="#Newtman._clip_positions_velocities!-Tuple{Any}"><code>Newtman._clip_positions_velocities!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Apply boundary conditions to both position and velocity for every <code>Particle</code> type object <code>P</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/pso.jl#L206-L209">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._create_rng-Tuple{}" href="#Newtman._create_rng-Tuple{}"><code>Newtman._create_rng</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Returns <code>num_rngs</code> number of statistically independent pseudo-random number generators by creating a master RNG and drawing numbers from it, these numbers will serve as seeds for the number of RNG&#39;s returned in the form of an <code>AbstractArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/pso.jl#L223-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._mean_std_results-Tuple{Any,Any}" href="#Newtman._mean_std_results-Tuple{Any,Any}"><code>Newtman._mean_std_results</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Receives an array of <code>values</code> and a <code>num_max</code> number, and returns the mean and standard deviation of them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/pso.jl#L239-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman._weight_decay-Tuple{Any,Any}" href="#Newtman._weight_decay-Tuple{Any,Any}"><code>Newtman._weight_decay</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute the corresponding weight decay depending the maximum number of iterations and the initial value for it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/pso.jl#L195-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Metaheuristic" href="#Newtman.Metaheuristic"><code>Newtman.Metaheuristic</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Metaheuristic</code></pre><p>Abstract type for metaheuristic algorithms, this makes a clear distinction between different classifications of metaheuristic algorithms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/solvers.jl#L8-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.OptimizationResults" href="#Newtman.OptimizationResults"><code>Newtman.OptimizationResults</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OptimizationResults{T, U, V, W}</code></pre><p>Type that formats the output of <a href="#Newtman.Solver"><code>Solver</code></a> to get better information from it.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: Stores the <em>solution</em> array from the solver, i.e. the solution that minimizes   the cost function.</li><li><code>min::U</code>: Stores the value obtained from evaluating the cost function with   <code>x</code>, i.e. the minima found.</li><li><code>impl::AbstractString</code>: Stores the name of the <code>Solver</code> used, i.e. the name or identifier of the   optimization algorithm.</li><li><code>iterations::Integer</code>: Stores the number of maximum iterations that the solver was run.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/solvers.jl#L35-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.OptimizationResultsParallel" href="#Newtman.OptimizationResultsParallel"><code>Newtman.OptimizationResultsParallel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OptimizationResultsParallel{T, U}</code></pre><p>Type that formats the output of an embarrassingly parallel implementation of <a href="#Newtman.Solver"><code>Solver</code></a> to get better information from it.</p><p><strong>Fields</strong></p><ul><li><code>x::T</code>: Stores the <em>solution</em> array from the solver, i.e. the solution that minimizes   the cost function. This is the mean value obtained from all the independent runs that were carried out.</li><li><code>err::U</code>: Stores the standard deviation from the <code>x</code> array.</li><li><code>min::U</code>: Stores the value obtained from evaluating the cost function with   <code>x</code>, i.e. the minima found.</li><li><code>impl::AbstractString</code>: Stores the name of the <code>Solver</code> used, i.e. the name or identifier of the   optimization algorithm.</li><li><code>iterations::Integer</code>: Stores the number of maximum iterations that the solver was run.</li><li><code>runs::Integer</code>: Stores the number of independent runs that were executed.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/solvers.jl#L65-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.PopulationBase" href="#Newtman.PopulationBase"><code>Newtman.PopulationBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PopulationBase</code></pre><p>Type for population-based algorithms that employ <a href="#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64"><code>Population</code></a>, i.e. subroutines that <em>mutate</em> an array of possible candidates in-place. An example of this type is <a href="#Newtman.PSO"><code>PSO</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/solvers.jl#L16-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Solver" href="#Newtman.Solver"><code>Newtman.Solver</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Solver</code></pre><p>Abstract super-type for every algorithm implementation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/solvers/solvers.jl#L1-L5">source</a></section><h2><a class="nav-anchor" id="Population-1" href="#Population-1">Population</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray" href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:AbstractArray"><code>Newtman.Particle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Particle(x::T, v::T, x_best::T, a::V, b::V)
    where {T&lt;:AbstractArray, V&lt;:AbstractFloat}</code></pre><p>A type that can hold information about current position, current velocity, the <em>best</em> candidate to a solution, as well as defining the bounds. The dimensions of the <code>Particle</code> are inferred from the length of the arrays.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Array that holds the <strong>positions</strong> of possible solutions.</li><li><code>v</code>: Array that holds <strong>velocities</strong> related to <code>x</code>.</li><li><code>x_best</code>: An element of <code>x</code> that determines the best position for the particle.</li><li><code>a</code>: lower bound for <code>x</code></li><li><code>b</code>: upper bound for <code>v</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia">p = Particle(zeros(3), rand(3), zeros(3), -1.0, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/population/types.jl#L26-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V&lt;:Int64 where T&lt;:AbstractFloat" href="#Newtman.Particle-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V}} where V&lt;:Int64 where T&lt;:AbstractFloat"><code>Newtman.Particle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Particle(a::T, b::T, n::V)
    where {T&lt;:AbstractFloat, V&lt;:Int}</code></pre><p><code>Particle</code> that can be created randomly using the bounds and the dimension needed.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>: lower bound for <code>x</code></li><li><code>b</code>: upper bound for <code>v</code></li><li><code>n</code>: dimension for <code>x</code>, <code>v</code>, and <code>x_best</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">p = Particle(-1.0, 1.0, 3)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/population/types.jl#L49-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64" href="#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64"><code>Newtman.Population</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Population(num_particles::T, dim::T, a::V, b::V)
    where {T&lt;:Int, V&lt;:AbstractFloat} -&gt; Vector{Particle}(undef, num_particles)</code></pre><p>An array of <code>Particle</code>s where each of them are bounded and are given a dimension. This is essentially a multi-dimensional array. It makes handling <code>Particle</code>s much easier.</p><p><strong>Arguments</strong></p><ul><li><code>num_particles</code>: Number of particles in the <code>Population</code>.</li><li><code>dim</code>: Dimension for every <code>Particle</code>.</li><li><code>a</code>: Lower bound for every <code>Particle</code>, this is shared across every instance.</li><li><code>b</code>: Upper bound for every <code>Particle</code>, this is shared across every instance.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">pop = Population(35, 4, -1.0, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/population/types.jl#L77-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64" href="#Newtman.Population-Union{Tuple{V}, Tuple{T}, Tuple{T,V,V}} where V&lt;:AbstractFloat where T&lt;:Int64"><code>Newtman.Population</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Population(dim::T, a::V, b::V)
    where {T&lt;:Int, V&lt;:AbstractFloat} -&gt; Vector{Particle}(undef, num_particles)</code></pre><p>If <code>num_particles</code> is not provided, it defaults to 5 <code>Particle</code>s in the <code>Population</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dim</code>: Dimension for every <code>Particle</code>.</li><li><code>a</code>: Lower bound for every <code>Particle</code>, this is shared across every instance.</li><li><code>b</code>: Upper bound for every <code>Particle</code>, this is shared across every instance.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia">pop = Population(4, -1.0, 1.0) # The same as Population(5, 4, -1.0, 1.0)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/population/types.jl#L107-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Newtman.Individual" href="#Newtman.Individual"><code>Newtman.Individual</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Individual</code></pre><p>Abstract super-type for types that contain their own information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/edwinb-ai/Newtman.jl/blob/543649f7f843d8f764eb18070200235829045b48/src/population/types.jl#L1-L5">source</a></section><footer><hr/><a class="previous" href="../guide/"><span class="direction">Previous</span><span class="title">Guide</span></a><a class="next" href="../license/"><span class="direction">Next</span><span class="title">License</span></a></footer></article></body></html>
